# Как мы установавливали серверы

## Что было до нас
Генералов Даниил и Матюхин Григорий хотели заняться машинным обучением.
Связавшись с руководителем кафедры, Малых Михаилом Дмитриевичем,
мы узнали, что у нас есть сервер с Nvidia Tesla K80:
сравнительно старой, но все равно полезной видеокартой.

Этот сервер имеет процессор Intel Xeon E5-2690 и 64ГБ оперативной памяти,
а также (на момент написания) NVMe SSD на 120ГБ и жесткий диск на 700ГБ.
Все это подключено к материнской плате Atermiter X99.
На сервере был запущен Debian 10 и драйвер версии ???(CUDA v.11.4).

Этот сервер имел некоторые проблемы:
- У него не было графической видеокарты, только Tesla, которая не имеет видеовыхода. Материнская плата также не имеет видеовыхода, и этот Intel Xeon не имеет интегрированой видеокарты.
- С каких-то старых попыток установить на него видеокарту он имел два загрузчика, и по умолчанию использовался неправильный. Есть настройка в BIOS для того, чтобы поменять порядок предпочтения загрузчиков, но она почему-то не работала.
- Tesla использует большое количество памяти на PCI-шине, из-за чего необходимо использовать `Above 4G Decoding`, который по умолчанию выключен.
- Но если `Above 4G Decoding` включен, то тогда графическая видеокарта показывает только черный экран до загрузки ОС.
- Если на ОС установлен драйвер Nvidia, то ОС пытается показывать свою консоль на видеокарте Nvidia, даже если у нее нет видеовыхода.


Из-за этих всех проблем, каждый раз, когда сервер перезагружался, было необходимо
идти в серверную комнату,
открывать корпус,
доставать Tesla-видеокарту,
вместо нее ставить обычную ("графическую") видеокарту,
сбрасывать BIOS (может быть графическая видеокарта не работает с `Above 4G Decoding` ???),
идти в настройки, включать Above 4G Decoding и выбрать правильный загрузчик,
затем поставить Tesla-видеокарту обратно.

Более того, перезагрузка периодически требовалась, потому что использование Tesla периодически приводило к тому, что видеокарта зависала особенным способом
(все видимые переменные в lspci становились полны `0xff`),
и после этого не отвечала на какие-либо команды.
Из такого состояния ее можно вывести только перезагрузкой.

## Что мы делали

### Первая попытка: Debian 10

Первым делом мы установили свежую копию Debian 10
на другой жесткий диск.
После этого мы использовали утилиту `nvidia-detect`, чтобы определить ту версию драйвера,
которая рекомендуется к установке,
а затем установили ее.
(Эта утилита и драйверы доступны из репозиториев имени `contrib` и `non-free`: их необходимо включить в `/etc/apt/sources.list`, а затем сделать `apt update`.)

Это устанавливает версию драйвера 418 (CUDA v.10.1).
Тот драйвер, который был раньше, был более новым.
У нас гипотеза, что более новый драйвер пытался отправить видеокарте команду,
которую она не понимает,
и из-за этого она зависала.
(В интернете мнения различаются по вопросу, совместима ли версия CUDA 11.4 с Tesla K80).

...TODO: написать про anaconda...

`conda install pytorch==1.7.1 torchvision==0.8.2 torchaudio==0.7.2 cudatoolkit=10.1 -c pytorch`

`conda install tensorflow-gpu cudatoolkit=10.1`

### Вторая попытка: Proxmox

Система с Debian 10 работала нормально.
Однако, ради удобства администрирования мы установили Proxmox VE.

[Proxmox VE](https://www.proxmox.com/en/proxmox-virtual-environment/overview) -- это по сути Debian с веб-интерфейсом для администрирования
виртуальных машин.
Для наших целей нас интересуют следующие фичи:

- Виртуальные машины могут получать доступ к PCI-ресурсам хоста, в частности к видеокартам.
- Виртуальные машины можно независимо от хоста перезагружать или переустанавливать на них ОС.
- Можно делать полную резервную копию виртуальной машины в онлайн-режиме.

По случайности, мы решили еще одну проблему со старым сервером:
теперь, когда хост не имеет драйверов для видеокарты Tesla,
он не пытается использовать ее для вывода изображения консоли.
В материнской плате два разъема PCIe,
поэтому во второй из них мы перманентно вставили графическую видеокарту.
Получить доступ к BIOS с ней не получится (из-за этой проблемы с `Above 4G Decoding`),
но после загрузки ядра Linux там будет видна консоль,
которую можно использовать, чтобы чинить возможные проблемы.

Из-за всего этого теперь сервер стал гораздо лучше, чем до нас.
Поскольку раньше его hostname был `atermiter`,
и он был улучшен,
то теперь он называется **`aterbetter`**.

Внутри Proxmox VE мы сначала создали виртуальную машину,
на которой воссоздали настройки Debian 10,
когда он был установлен на физическом железе,
и подключили обе половины видеокарты к ней.
(Tesla K80 имеет два разных видеочипа, каждый с 12ГБ памяти -- кажется, их можно использовать отдельно, но мы пока что это не пробовали.)

После этого мы попробовали установить Debian 12, и оказалось, что для него
также есть драйвер для этой видеокарты.
Это значит, что мы смогли переключиться на Debian 12, чтобы была более новая версия ОС.


## Текущее состояние: советы по администрированию

Для каждого человека создается собственный Linux-пользователь.
Для этого пользователя создается отдельный btrfs-subvolume -- так устанавливается квота на использование домашней директории.
Это выполняется с помощью скрипта в домашней директории root.

Мы пытались сделать так, чтобы Conda имела общие файлы между всеми пользователями --
так можно было бы избежать дублирования 6ГБ пространства для каждого пользователя.
Однако из-за каких-то сложных проблем с разрешениями нам пришлось отказаться от этой идеи:
теперь каждый пользователь имеет свой Conda в своем домашнем каталоге.
Для минимизации использования диска мы используем reflink в btrfs,
чтобы объединять дублирующиеся файлы на диске.

... TODO ...

### Хитрости и ловушки

Некоторые полезные факты, которые могут помочь вам при настройке этих серверов в будущем.

### Большой PCI и миф предсказуемых сетевых интерфейсов

Традиционно, сетевые интерфейсы в Linux именовались по своему типу и порядковому номеру: `eth0`, `wlan0` итд.
Однако этот подход имел проблемы: номера назначались по порядку инициализации сетевых интерфейсов,
который может различаться,
и поэтому, если есть несколько сетевых интерфейсов одного типа,
то при одной загрузке интерфейс может называться `eth0`, а при следующей -- `eth1`.

Вместо этого в systemd v197 (2013г) [были добавлены "предсказуемые имена интерфейсов"](https://systemd.io/PREDICTABLE_INTERFACE_NAMES/): теперь интерфейсы называются по своему расположению на PCI-шине, например `enp4s0`.

Но Tesla требует настолько много места на PCI-шине,
что она сдвигает все вещи вокруг себя, когда присутствует:
например, на `aterbetter`, если Tesla отсутствует, то сетевой интерфейс на материнской плате называется `enp4s0`,
а если Tesla подключена, то интерфейс называется `enp8s0`.

Это проблематично при начальной установке ОС.
Скорее всего, вы будете устанавливать ОС без подключенной Tesla,
потому что вы хотите иметь доступ к BIOS и изображению с графической видеокарты.
Однако, если вы устанавливаете Debian, то имя интерфейса для использования будет записано в `/etc/network/interfaces`
(даже если вы хотите использовать DHCP: тогда в этот файл будет записан тот факт, что вы хотите DHCP).
Потом, когда вы подключите Tesla, то имя интерфейса поменяется,
и теперь этот комп не появится в сети.

Чтобы это исправить, вам нужно будет сначала установить ОС без Tesla,
затем, до установки драйверов,
вставить Tesla в комп (оставив там графическую видеокарту тоже),
а затем загрузиться заново
и поменять настройку в `/etc/network/interfaces`, чтобы она соответствовала новому имени интерфейса.
После этого можно вынимать графическую видеокарту,
и затем после перезагрузки сеть должна подниматься правильно.

Если у вашего компа есть только один разъем PCIe,
то одновременно Tesla и графическую видеокарту держать нельзя.
Для такого случая рекомендуем установить NetworkManager
и настроить его использовать сетевой интерфейс этого компа (в частности удалив его из `/etc/network/interfaces`).
После этого поменять графическую видеокарту на Tesla.
NetworkManager сам определит, какой сетевой интерфейс использовать,
и поднимет сеть, чтобы можно было подключиться к компу по SSH.
После того, как это получится,
можно будет определить имя этого сетевого интерфейса
и обратно прописать его в `/etc/network/interfaces`
(или нет, если вас устраивает NetworkManager).

### Музыка в серверной

Когда мы первый раз отлаживали установку ОС, у которой была проблема с загрузкой в правильную ОС,
мы часто ждали долго, не зная, завис ли комп при загрузке или загрузился ли он.
Это особенно тяжело, когда графической видеокарты нет вообще,
но это также иногда сложно, когда она есть,
но не работает правильно с BIOS (как в `aterbetter`).

Чтобы помочь вам определить это,
мы решили на все сервера добавлять скрипт в автозагрузку,
который при поднятии сети играет музыку с помощью PC-Speaker.
Это -- фактически единственное устройство вывода,
которое есть у каждого сервера,
поэтому надо использовать его для такой индикации.

На Linux PC-Speaker можно использовать [`beep(1)`](https://linux.die.net/man/1/beep):
без аргументов она просто издает один писк.
Однако просто писк также иногда издают различные процессы в BIOS,
а также в загрузчике вроде GRUB.

Чтобы отличать эти ситуации от того, когда загружается система,
лучше пищать более узнаваемым способом.
Например, музыкой:
в https://github.com/ShaneMcC/beeps есть несколько скриптов,
которые издают разные звуки с помощью команды `beep`.

Выбирайте любимый из них,
затем скачайте его на сервер,
и добавьте его в systemd:

```bash
cat >> /etc/systemd/system/beep-on-startup.service <<EOF
[Unit]
Description=Beep on system startup
After=networking.service

[Service]
Type=oneshot
ExecStart=/usr/local/bin/carramelldansen.sh

[Install]
WantedBy=multi-user.target
EOF


systemctl daemon-reload
systemctl enable beep-on-startup.service
```

(Он запускается после `networking.service`, а не `network-online.target`,
потому что если есть проблема с настройкой сети,
то `network-online.target` никогда не будет достигнут,
но тот факт, что система была запущена, все-таки стоит отметить.)